#include "mathExpressionsHandling.hpp"
#include <algorithm>
#include <cctype>
#include <cmath>
#include <stack>
#include <stdexcept>
#include <vector>

static std::vector<std::string> tokenize(const std::string &expr) {
  std::vector<std::string> tokens;
  for (size_t i = 0; i < expr.size();) {
    if (std::isspace((unsigned char)expr[i])) {
      ++i;
      continue;
    }
    if (std::isdigit((unsigned char)expr[i])) {
      size_t j = i;
      while (j < expr.size() && std::isdigit((unsigned char)expr[j]))
        ++j;
      tokens.emplace_back(expr.substr(i, j - i));
      i = j;
    } else {
      if (expr[i] == '*' && i + 1 < expr.size() && expr[i + 1] == '*') {
        tokens.emplace_back("**");
        i += 2;
      } else {
        tokens.emplace_back(std::string(1, expr[i]));
        ++i;
      }
    }
  }
  return tokens;
}

static std::string join(const std::vector<std::string> &tokens) {
  std::string out;
  for (size_t i = 0; i < tokens.size(); ++i) {
    out += tokens[i];
    if (i + 1 < tokens.size())
      out += ' ';
  }
  return out;
}

template <typename T> bool isNum(const T &expression) {
  return !expression.empty() &&
         std::all_of(expression.begin(), expression.end(), [](char c) {
           return std::isdigit(static_cast<unsigned char>(c));
         });
}
template bool isNum<std::string>(const std::string &);

static int precedence(const std::string &op) {
  if (op == "+" || op == "-")
    return 1;
  if (op == "*" || op == "/")
    return 2;
  if (op == "^" || op == "**")
    return 3;
  return 0;
}

bool OperatorsHandling::isOperator(const std::string &expr) const {
  return operatorsPriority.find(expr) != operatorsPriority.end();
}

int OperatorsHandling::getOperatorPriority(const std::string &expr) const {
  auto it = operatorsPriority.find(expr);
  if (it == operatorsPriority.end())
    return -1;
  return it->second;
}

std::map<std::string, int> OperatorsHandling::operatorsPriority = {
    {"+", 1}, {"-", 1}, {"*", 2}, {"/", 2}, {"^", 3}, {"**", 3}};

std::string ExpressionConverter::infixToPostfix(const std::string &expr) const {
  auto tokens = tokenize(expr);
  std::vector<std::string> output;
  std::stack<std::string> ops;
  for (auto &tok : tokens) {
    if (isNum(tok)) {
      output.push_back(tok);
    } else if (tok == "(") {
      ops.push(tok);
    } else if (tok == ")") {
      while (!ops.empty() && ops.top() != "(") {
        output.push_back(ops.top());
        ops.pop();
      }
      if (!ops.empty())
        ops.pop();
    } else {
      while (!ops.empty() && precedence(ops.top()) >= precedence(tok)) {
        output.push_back(ops.top());
        ops.pop();
      }
      ops.push(tok);
    }
  }
  while (!ops.empty()) {
    output.push_back(ops.top());
    ops.pop();
  }
  return join(output);
}

std::string ExpressionConverter::infixToPrefix(const std::string &expr) const {
  auto tokens = tokenize(expr);
  std::reverse(tokens.begin(), tokens.end());
  for (auto &tok : tokens) {
    if (tok == "(")
      tok = ")";
    else if (tok == ")")
      tok = "(";
  }
  std::string revExpr = join(tokens);
  auto postfix = infixToPostfix(revExpr);
  auto postTokens = tokenize(postfix);
  std::reverse(postTokens.begin(), postTokens.end());
  return join(postTokens);
}

std::string
ExpressionConverter::postfixToPrefix(const std::string &expr) const {
  auto tokens = tokenize(expr);
  std::stack<std::vector<std::string>> st;
  for (auto &tok : tokens) {
    if (isNum(tok))
      st.push({tok});
    else {
      if (st.size() < 2)
        throw std::runtime_error("Invalid postfix");
      auto b = st.top();
      st.pop();
      auto a = st.top();
      st.pop();
      std::vector<std::string> comb = {tok};
      comb.insert(comb.end(), a.begin(), a.end());
      comb.insert(comb.end(), b.begin(), b.end());
      st.push(comb);
    }
  }
  if (st.size() != 1)
    throw std::runtime_error("Invalid postfix");
  return join(st.top());
}

std::string
ExpressionConverter::prefixToPostfix(const std::string &expr) const {
  auto tokens = tokenize(expr);
  std::stack<std::vector<std::string>> st;
  for (int i = (int)tokens.size() - 1; i >= 0; --i) {
    auto &tok = tokens[i];
    if (isNum(tok))
      st.push({tok});
    else {
      if (st.size() < 2)
        throw std::runtime_error("Invalid prefix");
      auto a = st.top();
      st.pop();
      auto b = st.top();
      st.pop();
      std::vector<std::string> comb = a;
      comb.insert(comb.end(), b.begin(), b.end());
      comb.push_back(tok);
      st.push(comb);
    }
  }
  if (st.size() != 1)
    throw std::runtime_error("Invalid prefix");
  return join(st.top());
}

std::string ExpressionConverter::postfixToInfix(const std::string &expr) const {
  auto tokens = tokenize(expr);
  std::stack<std::vector<std::string>> st;
  for (auto &tok : tokens) {
    if (isNum(tok))
      st.push({tok});
    else {
      if (st.size() < 2)
        throw std::runtime_error("Invalid postfix");
      auto b = st.top();
      st.pop();
      auto a = st.top();
      st.pop();
      std::vector<std::string> comb = {"("};
      comb.insert(comb.end(), a.begin(), a.end());
      comb.push_back(tok);
      comb.insert(comb.end(), b.begin(), b.end());
      comb.push_back(")");
      st.push(comb);
    }
  }
  if (st.size() != 1)
    throw std::runtime_error("Invalid postfix");
  return join(st.top());
}

std::string ExpressionConverter::prefixToInfix(const std::string &expr) const {
  auto tokens = tokenize(expr);
  std::stack<std::vector<std::string>> st;
  for (int i = (int)tokens.size() - 1; i >= 0; --i) {
    auto &tok = tokens[i];
    if (isNum(tok))
      st.push({tok});
    else {
      if (st.size() < 2)
        throw std::runtime_error("Invalid prefix");
      auto a = st.top();
      st.pop();
      auto b = st.top();
      st.pop();
      std::vector<std::string> comb = {"("};
      comb.insert(comb.end(), a.begin(), a.end());
      comb.push_back(tok);
      comb.insert(comb.end(), b.begin(), b.end());
      comb.push_back(")");
      st.push(comb);
    }
  }
  if (st.size() != 1)
    throw std::runtime_error("Invalid prefix");
  return join(st.top());
}

double ExpressionEvaluator::calcPostfix(const std::string &expr) const {
  auto tokens = tokenize(expr);
  std::stack<int> st;
  for (auto &tok : tokens) {
    if (isNum(tok))
      st.push(std::stoi(tok));
    else {
      if (st.size() < 2)
        throw std::runtime_error("Invalid postfix");
      int b = st.top();
      st.pop();
      int a = st.top();
      st.pop();
      if (tok == "+")
        st.push(a + b);
      else if (tok == "-")
        st.push(a - b);
      else if (tok == "*")
        st.push(a * b);
      else if (tok == "/")
        st.push(a / b);
      else if (tok == "^" || tok == "**")
        st.push((int)std::pow(a, b));
      else
        throw std::runtime_error("Unknown operator: " + tok);
    }
  }
  if (st.size() != 1)
    throw std::runtime_error("Invalid postfix");
  return st.top();
}

double ExpressionEvaluator::calcPrefix(const std::string &expr) const {
  auto tokens = tokenize(expr);
  std::stack<int> st;
  for (int i = (int)tokens.size() - 1; i >= 0; --i) {
    const auto &tok = tokens[i];
    if (isNum(tok))
      st.push(std::stoi(tok));
    else {
      if (st.size() < 2)
        throw std::runtime_error("Invalid prefix");
      int a = st.top();
      st.pop();
      int b = st.top();
      st.pop();
      if (tok == "+")
        st.push(a + b);
      else if (tok == "-")
        st.push(a - b);
      else if (tok == "*")
        st.push(a * b);
      else if (tok == "/")
        st.push(a / b);
      else if (tok == "^" || tok == "**")
        st.push((int)std::pow(a, b));
      else
        throw std::runtime_error("Unknown operator: " + tok);
    }
  }
  if (st.size() != 1)
    throw std::runtime_error("Invalid prefix");
  return st.top();
}

double ExpressionEvaluator::calcInfix(const std::string &expr) const {
  ExpressionConverter conv;
  std::string postfix = conv.infixToPostfix(expr);
  return calcPostfix(postfix);
}
